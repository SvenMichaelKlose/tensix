                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : FreeWare ANSI-C Compiler
                              3 ; Version 2.6.0 #4309 (Oct 17 2006)
                              4 ; This file generated Thu Oct 19 04:08:19 2006
                              5 ;--------------------------------------------------------
                              6 	.module proc
                              7 	.optsdcc -mz80
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _procs_sleeping
                             13 	.globl _procs_running
                             14 	.globl _proc_pool
                             15 	.globl _proc_id
                             16 	.globl _proc_holographic
                             17 	.globl _proc_context
                             18 	.globl _proc_current
                             19 	.globl _proc_init
                             20 	.globl _proc_create
                             21 	.globl _proc_exec
                             22 	.globl _proc_startup
                             23 	.globl _proc_kill
                             24 	.globl _exit
                             25 	.globl _proc_funexec
                             26 	.globl _proc_sleep
                             27 	.globl _proc_wakeup
                             28 	.globl _sleep
                             29 ;--------------------------------------------------------
                             30 ; special function registers
                             31 ;--------------------------------------------------------
                             32 ;--------------------------------------------------------
                             33 ;  ram data
                             34 ;--------------------------------------------------------
                             35 	.area _DATA
   0000                      36 _proc_current::
   0000                      37 	.ds 2
   0002                      38 _proc_context::
   0002                      39 	.ds 2
   0004                      40 _proc_holographic::
   0004                      41 	.ds 40
   002C                      42 _proc_id::
   002C                      43 	.ds 1
   002D                      44 _proc_pool::
   002D                      45 	.ds 11
   0038                      46 _procs_running::
   0038                      47 	.ds 4
   003C                      48 _procs_sleeping::
   003C                      49 	.ds 4
                             50 ;--------------------------------------------------------
                             51 ; overlayable items in  ram 
                             52 ;--------------------------------------------------------
                             53 	.area _OVERLAY
                             54 ;--------------------------------------------------------
                             55 ; external initialized ram data
                             56 ;--------------------------------------------------------
                             57 ;--------------------------------------------------------
                             58 ; global & static initialisations
                             59 ;--------------------------------------------------------
                             60 	.area _HOME
                             61 	.area _GSINIT
                             62 	.area _GSFINAL
                             63 	.area _GSINIT
                             64 ;--------------------------------------------------------
                             65 ; Home
                             66 ;--------------------------------------------------------
                             67 	.area _HOME
                             68 	.area _CODE
                             69 ;--------------------------------------------------------
                             70 ; code
                             71 ;--------------------------------------------------------
                             72 	.area _CODE
                             73 ;proc.c:54: proc_init ()
                             74 ;	genLabel
                             75 ;	genFunction
                             76 ;	---------------------------------
                             77 ; Function proc_init
                             78 ; ---------------------------------
   0000                      79 _proc_init_start::
   0000                      80 _proc_init:
                             81 ;proc.c:58: proc_id = -1; /* Holographic proc id must be -1! */
                             82 ;	genAssign
   0000 FD 21r2Cs00          83 	ld	iy,#_proc_id
   0004 FD 36 00 FF          84 	ld	0(iy),#0xFF
                             85 ;proc.c:61: p = POOL_CREATE(&proc_pool, PROC_MAX, struct proc);
                             86 ;	genIpush
                             87 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0008 21 28 00             88 	ld	hl,#0x0028
   000B E5                   89 	push	hl
                             90 ;	genIpush
   000C 21 10 00             91 	ld	hl,#0x0010
   000F E5                   92 	push	hl
                             93 ;	genIpush
   0010 21r2Ds00             94 	ld	hl,#_proc_pool
   0013 E5                   95 	push	hl
                             96 ;	genCall
   0014 CDr00s00             97 	call	_pool_create
   0017 44                   98 	ld	b,h
   0018 4D                   99 	ld	c,l
   0019 F1                  100 	pop	af
   001A F1                  101 	pop	af
   001B F1                  102 	pop	af
                            103 ;	genAssign
                            104 ;	(registers are the same)
                            105 ;proc.c:62: IASSERT(p == NULL, "proc: no mem");
                            106 ;	genCmpEq
                            107 ; genCmpEq: left 2, right 2, result 0
   001C 79                  108 	ld	a,c
   001D B0                  109 	or	a,b
   001E CAr24s00            110 	jp	z,00107$
   0021                     111 00106$:
   0021 C3r2Cs00            112 	jp	00102$
   0024                     113 00107$:
                            114 ;	genIpush
                            115 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0024 21r7Ds00            116 	ld	hl,#__str_0
   0027 E5                  117 	push	hl
                            118 ;	genCall
   0028 CDr00s00            119 	call	_panic
   002B F1                  120 	pop	af
                            121 ;	genLabel
   002C                     122 00102$:
                            123 ;proc.c:65: DEQUEUE_WIPE(&procs_sleeping);
                            124 ;	genPlus
                            125 ;	genPlusIncr
   002C 01r3Es00            126 	ld	bc,#_procs_sleeping + 2
                            127 ;	genAssign (pointer)
                            128 ;	isBitvar = 0
   002F 69                  129 	ld	l,c
   0030 60                  130 	ld	h,b
   0031 36 00               131 	ld	(hl),#0x00
   0033 23                  132 	inc	hl
   0034 36 00               133 	ld	(hl),#0x00
                            134 ;	genAssign (pointer)
                            135 ;	isBitvar = 0
   0036 21r3Cs00            136 	ld	hl,#_procs_sleeping
   0039 36 00               137 	ld	(hl),#0x00
   003B 23                  138 	inc	hl
   003C 36 00               139 	ld	(hl),#0x00
                            140 ;proc.c:66: DEQUEUE_WIPE(&procs_running);
                            141 ;	genPlus
                            142 ;	genPlusIncr
   003E 01r3As00            143 	ld	bc,#_procs_running + 2
                            144 ;	genAssign (pointer)
                            145 ;	isBitvar = 0
   0041 69                  146 	ld	l,c
   0042 60                  147 	ld	h,b
   0043 36 00               148 	ld	(hl),#0x00
   0045 23                  149 	inc	hl
   0046 36 00               150 	ld	(hl),#0x00
                            151 ;	genAssign (pointer)
                            152 ;	isBitvar = 0
   0048 21r38s00            153 	ld	hl,#_procs_running
   004B 36 00               154 	ld	(hl),#0x00
   004D 23                  155 	inc	hl
   004E 36 00               156 	ld	(hl),#0x00
                            157 ;proc.c:70: proc_current->name = "holographic";
                            158 ;	genAssign
   0050 ED 4Br00s00         159 	ld	bc,(_proc_current)
                            160 ;	genPlus
                            161 ;	genPlusIncr
                            162 ;	Can't optimise plus by inc, falling back to the normal way
   0054 79                  163 	ld	a,c
   0055 C6 26               164 	add	a,#0x26
   0057 4F                  165 	ld	c,a
   0058 78                  166 	ld	a,b
   0059 CE 00               167 	adc	a,#0x00
   005B 47                  168 	ld	b,a
                            169 ;	genAssign (pointer)
                            170 ;	isBitvar = 0
   005C 69                  171 	ld	l,c
   005D 60                  172 	ld	h,b
   005E 36r8A               173 	ld	(hl),#<__str_1
   0060 23                  174 	inc	hl
   0061 36s00               175 	ld	(hl),#>__str_1
                            176 ;proc.c:79: proc_context = NULL; /* Do not switch! */
                            177 ;	genAssign
   0063 FD 21r02s00         178 	ld	iy,#_proc_context
   0067 FD 36 00 00         179 	ld	0(iy),#0x00
   006B FD 36 01 00         180 	ld	1(iy),#0x00
                            181 ;proc.c:81: VERBOSE_BOOT_PRINTK("proc: %d tasks.\n", PROC_MAX);
                            182 ;	genIpush
                            183 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   006F 21 10 00            184 	ld	hl,#0x0010
   0072 E5                  185 	push	hl
                            186 ;	genIpush
   0073 21r96s00            187 	ld	hl,#__str_2
   0076 E5                  188 	push	hl
                            189 ;	genCall
   0077 CDr00s00            190 	call	_printk
   007A F1                  191 	pop	af
   007B F1                  192 	pop	af
                            193 ;	genLabel
   007C                     194 00103$:
                            195 ;	genEndFunction
   007C C9                  196 	ret
   007D                     197 _proc_init_end::
   007D                     198 __str_0:
   007D 70 72 6F 63 3A 20   199 	.ascii "proc: no mem"
        6E 6F 20 6D 65 6D
   0089 00                  200 	.db 0x00
   008A                     201 __str_1:
   008A 68 6F 6C 6F 67 72   202 	.ascii "holographic"
        61 70 68 69 63
   0095 00                  203 	.db 0x00
   0096                     204 __str_2:
   0096 70 72 6F 63 3A 20   205 	.ascii "proc: %d tasks."
        25 64 20 74 61 73
        6B 73 2E
   00A5 0A                  206 	.db 0x0A
   00A6 00                  207 	.db 0x00
                            208 ;proc.c:91: proc_create (struct proc **proc, char *name)
                            209 ;	genLabel
                            210 ;	genFunction
                            211 ;	---------------------------------
                            212 ; Function proc_create
                            213 ; ---------------------------------
   00A7                     214 _proc_create_start::
   00A7                     215 _proc_create:
   00A7 DD E5               216 	push	ix
   00A9 DD 21 00 00         217 	ld	ix,#0
   00AD DD 39               218 	add	ix,sp
   00AF 21 FE FF            219 	ld	hl,#-2
   00B2 39                  220 	add	hl,sp
   00B3 F9                  221 	ld	sp,hl
                            222 ;proc.c:99: p = POOL_SALLOC(&proc_pool);
                            223 ;	genIpush
                            224 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   00B4 21r2Ds00            225 	ld	hl,#_proc_pool
   00B7 E5                  226 	push	hl
                            227 ;	genCall
   00B8 CDr00s00            228 	call	_pool_salloc
   00BB 44                  229 	ld	b,h
   00BC 4D                  230 	ld	c,l
   00BD F1                  231 	pop	af
                            232 ;	genAssign
                            233 ;	(registers are the same)
                            234 ;	genAssign
                            235 ;	(registers are the same)
                            236 ;proc.c:100: ERRCHK(p == NULL, ENOMEM);
                            237 ;	genCmpEq
                            238 ; genCmpEq: left 2, right 2, result 0
   00BE 79                  239 	ld	a,c
   00BF B0                  240 	or	a,b
   00C0 CArC6s00            241 	jp	z,00113$
   00C3                     242 00112$:
   00C3 C3rCCs00            243 	jp	00102$
   00C6                     244 00113$:
                            245 ;	genRet
                            246 ; Dump of IC_LEFT: type AOP_LIT size 2
   00C6 21 01 00            247 	ld	hl,#0x0001
   00C9 C3r67s01            248 	jp	00107$
                            249 ;	genLabel
   00CC                     250 00102$:
                            251 ;proc.c:101: p->name = name;
                            252 ;	genPlus
                            253 ;	genPlusIncr
                            254 ;	Can't optimise plus by inc, falling back to the normal way
   00CC 79                  255 	ld	a,c
   00CD C6 26               256 	add	a,#0x26
   00CF 5F                  257 	ld	e,a
   00D0 78                  258 	ld	a,b
   00D1 CE 00               259 	adc	a,#0x00
   00D3 57                  260 	ld	d,a
                            261 ;	genAssign (pointer)
                            262 ;	AOP_STK for 
                            263 ;	isBitvar = 0
   00D4 6B                  264 	ld	l,e
   00D5 62                  265 	ld	h,d
   00D6 DD 7E 06            266 	ld	a,6(ix)
   00D9 77                  267 	ld	(hl),a
   00DA 23                  268 	inc	hl
   00DB DD 7E 07            269 	ld	a,7(ix)
   00DE 77                  270 	ld	(hl),a
                            271 ;proc.c:102: p->state = 0;
                            272 ;	genPlus
                            273 ;	genPlusIncr
                            274 ;	Can't optimise plus by inc, falling back to the normal way
   00DF 79                  275 	ld	a,c
   00E0 C6 20               276 	add	a,#0x20
   00E2 5F                  277 	ld	e,a
   00E3 78                  278 	ld	a,b
   00E4 CE 00               279 	adc	a,#0x00
   00E6 57                  280 	ld	d,a
                            281 ;	genAssign (pointer)
                            282 ;	isBitvar = 0
   00E7 3E 00               283 	ld	a,#0x00
   00E9 12                  284 	ld	(de),a
                            285 ;proc.c:104: p->ticks_run = 0;
                            286 ;	genPlus
                            287 ;	genPlusIncr
                            288 ;	Can't optimise plus by inc, falling back to the normal way
   00EA 79                  289 	ld	a,c
   00EB C6 23               290 	add	a,#0x23
   00ED 5F                  291 	ld	e,a
   00EE 78                  292 	ld	a,b
   00EF CE 00               293 	adc	a,#0x00
   00F1 57                  294 	ld	d,a
                            295 ;	genAssign (pointer)
                            296 ;	isBitvar = 0
   00F2 6B                  297 	ld	l,e
   00F3 62                  298 	ld	h,d
   00F4 36 00               299 	ld	(hl),#0x00
   00F6 23                  300 	inc	hl
   00F7 36 00               301 	ld	(hl),#0x00
                            302 ;proc.c:106: p->id = proc_id;
                            303 ;	genPlus
                            304 ;	genPlusIncr
                            305 ;	Can't optimise plus by inc, falling back to the normal way
   00F9 79                  306 	ld	a,c
   00FA C6 25               307 	add	a,#0x25
   00FC 5F                  308 	ld	e,a
   00FD 78                  309 	ld	a,b
   00FE CE 00               310 	adc	a,#0x00
   0100 57                  311 	ld	d,a
                            312 ;	genAssign (pointer)
                            313 ;	isBitvar = 0
   0101 FD 21r2Cs00         314 	ld	iy,#_proc_id
   0105 FD 7E 00            315 	ld	a,0(iy)
   0108 12                  316 	ld	(de),a
                            317 ;proc.c:109: proc_id++;
                            318 ;	genPlus
                            319 ;	genPlusIncr
   0109 FD 34 00            320 	inc	0(iy)
                            321 ;proc.c:110: if (proc_id == 0)
                            322 ;	genIfx
   010C AF                  323 	xor	a,a
   010D FD B6 00            324 	or	a,0(iy)
   0110 C2r17s01            325 	jp	nz,00104$
                            326 ;proc.c:111: proc_id = 1;
                            327 ;	genAssign
   0113 FD 36 00 01         328 	ld	0(iy),#0x01
                            329 ;	genLabel
   0117                     330 00104$:
                            331 ;proc.c:114: mem_init_proc (p);
                            332 ;	genIpush
                            333 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0117 C5                  334 	push	bc
   0118 C5                  335 	push	bc
                            336 ;	genCall
   0119 CDr00s00            337 	call	_mem_init_proc
   011C F1                  338 	pop	af
   011D C1                  339 	pop	bc
                            340 ;proc.c:118: err = fs_init_proc (p);
                            341 ;	genIpush
                            342 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   011E C5                  343 	push	bc
   011F C5                  344 	push	bc
                            345 ;	genCall
   0120 CDr00s00            346 	call	_fs_init_proc
   0123 54                  347 	ld	d,h
   0124 5D                  348 	ld	e,l
   0125 F1                  349 	pop	af
   0126 C1                  350 	pop	bc
                            351 ;	genAssign
                            352 ;	AOP_STK for _proc_create_err_1_1
   0127 DD 73 FE            353 	ld	-2(ix),e
   012A DD 72 FF            354 	ld	-1(ix),d
                            355 ;proc.c:119: if (err != ENONE) {
                            356 ;	genCmpEq
                            357 ;	AOP_STK for _proc_create_err_1_1
                            358 ; genCmpEq: left 2, right 2, result 0
   012D DD 7E FE            359 	ld	a,-2(ix)
   0130 DD B6 FF            360 	or	a,-1(ix)
   0133 CAr49s01            361 	jp	z,00106$
   0136                     362 00114$:
                            363 ;proc.c:121: POOL_SFREE(&proc_pool, p);
                            364 ;	genPlus
                            365 ;	genPlusIncr
   0136 11r31s00            366 	ld	de,#_proc_pool + 4
                            367 ;	genIpush
                            368 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0139 C5                  369 	push	bc
                            370 ;	genIpush
   013A D5                  371 	push	de
                            372 ;	genCall
   013B CDr00s00            373 	call	_dequeue_push
   013E F1                  374 	pop	af
   013F F1                  375 	pop	af
                            376 ;proc.c:122: return err;
                            377 ;	genRet
                            378 ;	AOP_STK for _proc_create_err_1_1
                            379 ; Dump of IC_LEFT: type AOP_STK size 2
                            380 ;	 aop_stk -2
   0140 DD 6E FE            381 	ld	l,-2(ix)
   0143 DD 66 FF            382 	ld	h,-1(ix)
   0146 C3r67s01            383 	jp	00107$
                            384 ;	genLabel
   0149                     385 00106$:
                            386 ;proc.c:127: CLIST_INSERT(&procs_sleeping, p);
                            387 ;	genIpush
                            388 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0149 C5                  389 	push	bc
   014A C5                  390 	push	bc
                            391 ;	genIpush
   014B 21r3Cs00            392 	ld	hl,#_procs_sleeping
   014E E5                  393 	push	hl
                            394 ;	genCall
   014F CDr00s00            395 	call	_clist_insert
   0152 F1                  396 	pop	af
   0153 F1                  397 	pop	af
   0154 C1                  398 	pop	bc
                            399 ;proc.c:129: *proc = p;
                            400 ;	genAssign
                            401 ;	AOP_STK for 
   0155 DD 5E 04            402 	ld	e,4(ix)
   0158 DD 56 05            403 	ld	d,5(ix)
   015B D5                  404 	push	de
   015C FD E1               405 	pop	iy
                            406 ;	genAssign (pointer)
                            407 ;	isBitvar = 0
   015E FD 71 00            408 	ld	0(iy),c
   0161 FD 70 01            409 	ld	1(iy),b
                            410 ;proc.c:131: return ENONE;
                            411 ;	genRet
                            412 ; Dump of IC_LEFT: type AOP_LIT size 2
   0164 21 00 00            413 	ld	hl,#0x0000
                            414 ;	genLabel
   0167                     415 00107$:
                            416 ;	genEndFunction
   0167 DD F9               417 	ld	sp,ix
   0169 DD E1               418 	pop	ix
   016B C9                  419 	ret
   016C                     420 _proc_create_end::
                            421 ;proc.c:143: proc_exec (struct proc *proc, void *entry)
                            422 ;	genLabel
                            423 ;	genFunction
                            424 ;	---------------------------------
                            425 ; Function proc_exec
                            426 ; ---------------------------------
   016C                     427 _proc_exec_start::
   016C                     428 _proc_exec:
   016C DD E5               429 	push	ix
   016E DD 21 00 00         430 	ld	ix,#0
   0172 DD 39               431 	add	ix,sp
   0174 21 FE FF            432 	ld	hl,#-2
   0177 39                  433 	add	hl,sp
   0178 F9                  434 	ld	sp,hl
                            435 ;proc.c:152: if (proc->stacksize != 0) {
                            436 ;	genAssign
                            437 ;	AOP_STK for 
   0179 DD 4E 04            438 	ld	c,4(ix)
   017C DD 46 05            439 	ld	b,5(ix)
                            440 ;	genPlus
                            441 ;	genPlusIncr
                            442 ;	Can't optimise plus by inc, falling back to the normal way
   017F 79                  443 	ld	a,c
   0180 C6 0E               444 	add	a,#0x0E
   0182 5F                  445 	ld	e,a
   0183 78                  446 	ld	a,b
   0184 CE 00               447 	adc	a,#0x00
   0186 57                  448 	ld	d,a
                            449 ;	genPointerGet
   0187 6B                  450 	ld	l,e
   0188 62                  451 	ld	h,d
   0189 5E                  452 	ld	e,(hl)
   018A 23                  453 	inc	hl
   018B 56                  454 	ld	d,(hl)
                            455 ;	genCmpEq
                            456 ; genCmpEq: left 2, right 2, result 0
   018C 7B                  457 	ld	a,e
   018D B2                  458 	or	a,d
   018E CArC9s01            459 	jp	z,00104$
   0191                     460 00110$:
                            461 ;proc.c:153: proc->stack = pmalloc (proc->stacksize, proc);
                            462 ;	genPlus
                            463 ;	AOP_STK for _proc_exec_sloc1_1_0
                            464 ;	genPlusIncr
                            465 ;	Can't optimise plus by inc, falling back to the normal way
   0191 79                  466 	ld	a,c
   0192 C6 0C               467 	add	a,#0x0C
   0194 DD 77 FE            468 	ld	-2(ix),a
   0197 78                  469 	ld	a,b
   0198 CE 00               470 	adc	a,#0x00
   019A DD 77 FF            471 	ld	-1(ix),a
                            472 ;	genIpush
                            473 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   019D C5                  474 	push	bc
   019E C5                  475 	push	bc
                            476 ;	genIpush
   019F D5                  477 	push	de
                            478 ;	genCall
   01A0 CDr00s00            479 	call	_pmalloc
   01A3 54                  480 	ld	d,h
   01A4 5D                  481 	ld	e,l
   01A5 F1                  482 	pop	af
   01A6 F1                  483 	pop	af
   01A7 C1                  484 	pop	bc
                            485 ;	genAssign (pointer)
                            486 ;	AOP_STK for _proc_exec_sloc1_1_0
                            487 ;	isBitvar = 0
   01A8 DD 6E FE            488 	ld	l,-2(ix)
   01AB DD 66 FF            489 	ld	h,-1(ix)
   01AE 73                  490 	ld	(hl),e
   01AF 23                  491 	inc	hl
   01B0 72                  492 	ld	(hl),d
                            493 ;proc.c:154: ERRCGOTO(proc->stack == NULL, ENOMEM, error1);
                            494 ;	genAssign
                            495 ;	AOP_STK for 
   01B1 DD 5E 04            496 	ld	e,4(ix)
   01B4 DD 56 05            497 	ld	d,5(ix)
                            498 ;	genPlus
                            499 ;	genPlusIncr
                            500 ;	Can't optimise plus by inc, falling back to the normal way
   01B7 7B                  501 	ld	a,e
   01B8 C6 0C               502 	add	a,#0x0C
   01BA 5F                  503 	ld	e,a
   01BB 7A                  504 	ld	a,d
   01BC CE 00               505 	adc	a,#0x00
   01BE 57                  506 	ld	d,a
                            507 ;	genPointerGet
   01BF 6B                  508 	ld	l,e
   01C0 62                  509 	ld	h,d
   01C1 5E                  510 	ld	e,(hl)
   01C2 23                  511 	inc	hl
   01C3 56                  512 	ld	d,(hl)
                            513 ;	genCmpEq
                            514 ; genCmpEq: left 2, right 2, result 0
   01C4 7B                  515 	ld	a,e
   01C5 B2                  516 	or	a,d
   01C6 CAr0Bs02            517 	jp	z,00105$
   01C9                     518 00111$:
                            519 ;	genLabel
   01C9                     520 00104$:
                            521 ;proc.c:158: proc->machdep = pmalloc (PAGESIZE * 4, proc);
                            522 ;	genPlus
                            523 ;	genPlusIncr
                            524 ;	Can't optimise plus by inc, falling back to the normal way
   01C9 79                  525 	ld	a,c
   01CA C6 1E               526 	add	a,#0x1E
   01CC 5F                  527 	ld	e,a
   01CD 78                  528 	ld	a,b
   01CE CE 00               529 	adc	a,#0x00
   01D0 57                  530 	ld	d,a
                            531 ;	genIpush
                            532 ; _saveRegsForCall: sendSetSize: 0 deInUse: 1 bcInUse: 0 deSending: 0
   01D1 D5                  533 	push	de
   01D2 C5                  534 	push	bc
                            535 ;	genIpush
   01D3 21 00 04            536 	ld	hl,#0x0400
   01D6 E5                  537 	push	hl
                            538 ;	genCall
   01D7 CDr00s00            539 	call	_pmalloc
   01DA 44                  540 	ld	b,h
   01DB 4D                  541 	ld	c,l
   01DC F1                  542 	pop	af
   01DD F1                  543 	pop	af
   01DE D1                  544 	pop	de
                            545 ;	genAssign (pointer)
                            546 ;	isBitvar = 0
   01DF 6B                  547 	ld	l,e
   01E0 62                  548 	ld	h,d
   01E1 71                  549 	ld	(hl),c
   01E2 23                  550 	inc	hl
   01E3 70                  551 	ld	(hl),b
                            552 ;proc.c:160: machdep_proc_enter (proc, entry);
                            553 ;	genIpush
                            554 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                            555 ;	AOP_STK for 
   01E4 DD 6E 06            556 	ld	l,6(ix)
   01E7 DD 66 07            557 	ld	h,7(ix)
   01EA E5                  558 	push	hl
                            559 ;	genIpush
                            560 ;	AOP_STK for 
   01EB DD 6E 04            561 	ld	l,4(ix)
   01EE DD 66 05            562 	ld	h,5(ix)
   01F1 E5                  563 	push	hl
                            564 ;	genCall
   01F2 CDr00s00            565 	call	_machdep_proc_enter
   01F5 F1                  566 	pop	af
   01F6 F1                  567 	pop	af
                            568 ;proc.c:164: proc_wakeup (proc);
                            569 ;	genIpush
                            570 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                            571 ;	AOP_STK for 
   01F7 DD 6E 04            572 	ld	l,4(ix)
   01FA DD 66 05            573 	ld	h,5(ix)
   01FD E5                  574 	push	hl
                            575 ;	genCall
   01FE CDr24s05            576 	call	_proc_wakeup
   0201 F1                  577 	pop	af
                            578 ;proc.c:165: MANUAL_SWITCH();
                            579 ;	genCall
                            580 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0202 CDr00s00            581 	call	_machdep_switch
                            582 ;proc.c:169: return ENONE;
                            583 ;	genRet
                            584 ; Dump of IC_LEFT: type AOP_LIT size 2
   0205 21 00 00            585 	ld	hl,#0x0000
   0208 C3r0Es02            586 	jp	00106$
                            587 ;proc.c:171: error1:
                            588 ;	genLabel
   020B                     589 00105$:
                            590 ;proc.c:172: return err;
                            591 ;	genRet
                            592 ; Dump of IC_LEFT: type AOP_LIT size 2
   020B 21 01 00            593 	ld	hl,#0x0001
                            594 ;	genLabel
   020E                     595 00106$:
                            596 ;	genEndFunction
   020E DD F9               597 	ld	sp,ix
   0210 DD E1               598 	pop	ix
   0212 C9                  599 	ret
   0213                     600 _proc_exec_end::
                            601 ;proc.c:181: proc_startup (void *func)
                            602 ;	genLabel
                            603 ;	genFunction
                            604 ;	---------------------------------
                            605 ; Function proc_startup
                            606 ; ---------------------------------
   0213                     607 _proc_startup_start::
   0213                     608 _proc_startup:
   0213 DD E5               609 	push	ix
   0215 DD 21 00 00         610 	ld	ix,#0
   0219 DD 39               611 	add	ix,sp
                            612 ;proc.c:187: proc_context = CURRENT_PROC(); /* XXX explain this. */
                            613 ;	genAssign
   021B 2Ar00s00            614 	ld	hl,(_proc_current)
   021E FD 21r02s00         615 	ld	iy,#_proc_context
   0222 FD 75 00            616 	ld	0(iy),l
   0225 FD 74 01            617 	ld	1(iy),h
                            618 ;proc.c:188: ASSERT(func == NULL, "proc_startup: no entry\n");
                            619 ;	genCmpEq
                            620 ;	AOP_STK for 
                            621 ; genCmpEq: left 2, right 2, result 0
   0228 DD 7E 04            622 	ld	a,4(ix)
   022B DD B6 05            623 	or	a,5(ix)
   022E CAr34s02            624 	jp	z,00107$
   0231                     625 00106$:
   0231 C3r3Cs02            626 	jp	00102$
   0234                     627 00107$:
                            628 ;	genIpush
                            629 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0234 21r56s02            630 	ld	hl,#__str_3
   0237 E5                  631 	push	hl
                            632 ;	genCall
   0238 CDr00s00            633 	call	_panic
   023B F1                  634 	pop	af
                            635 ;	genLabel
   023C                     636 00102$:
                            637 ;proc.c:189: ((func_t) func) ();
                            638 ;	genAssign
                            639 ;	AOP_STK for 
   023C DD 4E 04            640 	ld	c,4(ix)
   023F DD 46 05            641 	ld	b,5(ix)
                            642 ;	genPcall
                            643 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0242 C5                  644 	push	bc
   0243 21r4As02            645 	ld	hl,#00108$
   0246 E5                  646 	push	hl
   0247 69                  647 	ld	l,c
   0248 60                  648 	ld	h,b
   0249 E9                  649 	jp	(hl)
   024A                     650 00108$:
   024A C1                  651 	pop	bc
                            652 ;proc.c:191: exit (ENONE);
                            653 ;	genIpush
                            654 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   024B 21 00 00            655 	ld	hl,#0x0000
   024E E5                  656 	push	hl
                            657 ;	genCall
   024F CDr6Ds03            658 	call	_exit
   0252 F1                  659 	pop	af
                            660 ;	genLabel
   0253                     661 00103$:
                            662 ;	genEndFunction
   0253 DD E1               663 	pop	ix
   0255 C9                  664 	ret
   0256                     665 _proc_startup_end::
   0256                     666 __str_3:
   0256 70 72 6F 63 5F 73   667 	.ascii "proc_startup: no entry"
        74 61 72 74 75 70
        3A 20 6E 6F 20 65
        6E 74 72 79
   026C 0A                  668 	.db 0x0A
   026D 00                  669 	.db 0x00
                            670 ;proc.c:196: proc_kill (struct proc *proc)
                            671 ;	genLabel
                            672 ;	genFunction
                            673 ;	---------------------------------
                            674 ; Function proc_kill
                            675 ; ---------------------------------
   026E                     676 _proc_kill_start::
   026E                     677 _proc_kill:
   026E DD E5               678 	push	ix
   0270 DD 21 00 00         679 	ld	ix,#0
   0274 DD 39               680 	add	ix,sp
   0276 21 FE FF            681 	ld	hl,#-2
   0279 39                  682 	add	hl,sp
   027A F9                  683 	ld	sp,hl
                            684 ;proc.c:205: LOCK_KILL_PROC(proc);
                            685 ;	genAssign
                            686 ;	AOP_STK for 
   027B DD 4E 04            687 	ld	c,4(ix)
   027E DD 46 05            688 	ld	b,5(ix)
                            689 ;	genPlus
                            690 ;	genPlusIncr
                            691 ;	Can't optimise plus by inc, falling back to the normal way
   0281 79                  692 	ld	a,c
   0282 C6 21               693 	add	a,#0x21
   0284 5F                  694 	ld	e,a
   0285 78                  695 	ld	a,b
   0286 CE 00               696 	adc	a,#0x00
   0288 57                  697 	ld	d,a
                            698 ;	genPointerGet
   0289 6B                  699 	ld	l,e
   028A 62                  700 	ld	h,d
   028B 5E                  701 	ld	e,(hl)
   028C 23                  702 	inc	hl
   028D 56                  703 	ld	d,(hl)
                            704 ;	genIfx
   028E 7B                  705 	ld	a,e
   028F B2                  706 	or	a,d
   0290 CAr9As02            707 	jp	z,00102$
                            708 ;	genIpush
                            709 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0293 C5                  710 	push	bc
   0294 D5                  711 	push	de
                            712 ;	genCall
   0295 CDr00s00            713 	call	_lock_unref
   0298 F1                  714 	pop	af
   0299 C1                  715 	pop	bc
                            716 ;	genLabel
   029A                     717 00102$:
                            718 ;proc.c:209: fs_kill_proc (proc);
                            719 ;	genIpush
                            720 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   029A C5                  721 	push	bc
                            722 ;	genCall
   029B CDr00s00            723 	call	_fs_kill_proc
   029E F1                  724 	pop	af
                            725 ;proc.c:212: mem_kill_proc (proc);
                            726 ;	genIpush
                            727 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                            728 ;	AOP_STK for 
   029F DD 6E 04            729 	ld	l,4(ix)
   02A2 DD 66 05            730 	ld	h,5(ix)
   02A5 E5                  731 	push	hl
                            732 ;	genCall
   02A6 CDr00s00            733 	call	_mem_kill_proc
   02A9 F1                  734 	pop	af
                            735 ;proc.c:216: proc_wakeup (proc);
                            736 ;	genIpush
                            737 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                            738 ;	AOP_STK for 
   02AA DD 6E 04            739 	ld	l,4(ix)
   02AD DD 66 05            740 	ld	h,5(ix)
   02B0 E5                  741 	push	hl
                            742 ;	genCall
   02B1 CDr24s05            743 	call	_proc_wakeup
   02B4 F1                  744 	pop	af
                            745 ;proc.c:221: next = (struct proc *) proc->next;
                            746 ;	genAssign
                            747 ;	AOP_STK for 
   02B5 DD 4E 04            748 	ld	c,4(ix)
   02B8 DD 46 05            749 	ld	b,5(ix)
                            750 ;	genPlus
                            751 ;	genPlusIncr
   02BB 59                  752 	ld	e,c
   02BC 50                  753 	ld	d,b
   02BD 13                  754 	inc	de
   02BE 13                  755 	inc	de
                            756 ;	genPointerGet
   02BF 6B                  757 	ld	l,e
   02C0 62                  758 	ld	h,d
   02C1 5E                  759 	ld	e,(hl)
   02C2 23                  760 	inc	hl
   02C3 56                  761 	ld	d,(hl)
                            762 ;	genAssign
                            763 ;	AOP_STK for _proc_kill_next_1_1
   02C4 DD 73 FE            764 	ld	-2(ix),e
   02C7 DD 72 FF            765 	ld	-1(ix),d
                            766 ;proc.c:222: if (next == proc_current)
                            767 ;	genCmpEq
                            768 ;	AOP_STK for _proc_kill_next_1_1
                            769 ; genCmpEq: left 2, right 2, result 0
   02CA FD 21r00s00         770 	ld	iy,#_proc_current
   02CE FD 7E 00            771 	ld	a,0(iy)
   02D1 DD BE FE            772 	cp	-2(ix)
   02D4 C2rE0s02            773 	jp	nz,00119$
   02D7 FD 7E 01            774 	ld	a,1(iy)
   02DA DD BE FF            775 	cp	-1(ix)
   02DD CArE3s02            776 	jp	z,00120$
   02E0                     777 00119$:
   02E0 C3rEBs02            778 	jp	00104$
   02E3                     779 00120$:
                            780 ;proc.c:223: next = NULL;
                            781 ;	genAssign
                            782 ;	AOP_STK for _proc_kill_next_1_1
   02E3 DD 36 FE 00         783 	ld	-2(ix),#0x00
   02E7 DD 36 FF 00         784 	ld	-1(ix),#0x00
                            785 ;	genLabel
   02EB                     786 00104$:
                            787 ;proc.c:226: CLIST_REMOVE(&procs_running, proc);
                            788 ;	genAssign
   02EB 59                  789 	ld	e,c
   02EC 50                  790 	ld	d,b
                            791 ;	genIpush
                            792 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   02ED C5                  793 	push	bc
   02EE D5                  794 	push	de
                            795 ;	genIpush
   02EF 21r38s00            796 	ld	hl,#_procs_running
   02F2 E5                  797 	push	hl
                            798 ;	genCall
   02F3 CDr00s00            799 	call	_clist_remove
   02F6 F1                  800 	pop	af
   02F7 F1                  801 	pop	af
   02F8 C1                  802 	pop	bc
                            803 ;proc.c:234: POOL_SFREE(&proc_pool, proc);
                            804 ;	genAssign
                            805 ;	AOP_STK for 
   02F9 DD 71 04            806 	ld	4(ix),c
   02FC DD 70 05            807 	ld	5(ix),b
                            808 ;	genPlus
                            809 ;	genPlusIncr
   02FF 11r31s00            810 	ld	de,#_proc_pool + 4
                            811 ;	genIpush
                            812 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0302 C5                  813 	push	bc
                            814 ;	AOP_STK for 
   0303 DD 6E 04            815 	ld	l,4(ix)
   0306 DD 66 05            816 	ld	h,5(ix)
   0309 E5                  817 	push	hl
                            818 ;	genIpush
   030A D5                  819 	push	de
                            820 ;	genCall
   030B CDr00s00            821 	call	_dequeue_push
   030E F1                  822 	pop	af
   030F F1                  823 	pop	af
   0310 C1                  824 	pop	bc
                            825 ;proc.c:237: if (proc == proc_current) {
                            826 ;	genCmpEq
                            827 ; genCmpEq: left 2, right 2, result 0
   0311 FD 21r00s00         828 	ld	iy,#_proc_current
   0315 FD 7E 00            829 	ld	a,0(iy)
   0318 B9                  830 	cp	c
   0319 C2r23s03            831 	jp	nz,00121$
   031C FD 7E 01            832 	ld	a,1(iy)
   031F B8                  833 	cp	b
   0320 CAr26s03            834 	jp	z,00122$
   0323                     835 00121$:
   0323 C3r55s03            836 	jp	00109$
   0326                     837 00122$:
                            838 ;proc.c:238: if (next != NULL)
                            839 ;	genCmpEq
                            840 ;	AOP_STK for _proc_kill_next_1_1
                            841 ; genCmpEq: left 2, right 2, result 0
   0326 DD 7E FE            842 	ld	a,-2(ix)
   0329 DD B6 FF            843 	or	a,-1(ix)
   032C CAr45s03            844 	jp	z,00106$
   032F                     845 00123$:
                            846 ;proc.c:239: proc_current = (struct proc *) next->prev;
                            847 ;	genPointerGet
                            848 ;	AOP_STK for _proc_kill_next_1_1
   032F DD 6E FE            849 	ld	l,-2(ix)
   0332 DD 66 FF            850 	ld	h,-1(ix)
   0335 7E                  851 	ld	a,(hl)
   0336 FD 21r00s00         852 	ld	iy,#_proc_current
   033A FD 77 00            853 	ld	0(iy),a
   033D 23                  854 	inc	hl
   033E 7E                  855 	ld	a,(hl)
   033F FD 77 01            856 	ld	1(iy),a
                            857 ;	genGoto
   0342 C3r55s03            858 	jp	00109$
                            859 ;	genLabel
   0345                     860 00106$:
                            861 ;proc.c:241: proc_current = next;
                            862 ;	genAssign
                            863 ;	AOP_STK for _proc_kill_next_1_1
   0345 DD 7E FE            864 	ld	a,-2(ix)
   0348 FD 21r00s00         865 	ld	iy,#_proc_current
   034C FD 77 00            866 	ld	0(iy),a
   034F DD 7E FF            867 	ld	a,-1(ix)
   0352 FD 77 01            868 	ld	1(iy),a
                            869 ;	genLabel
   0355                     870 00109$:
                            871 ;proc.c:246: if (proc_current == NULL)
                            872 ;	genCmpEq
                            873 ; genCmpEq: left 2, right 2, result 0
   0355 FD 21r00s00         874 	ld	iy,#_proc_current
   0359 FD 7E 00            875 	ld	a,0(iy)
   035C FD B6 01            876 	or	a,1(iy)
   035F CAr65s03            877 	jp	z,00125$
   0362                     878 00124$:
   0362 C3r68s03            879 	jp	00112$
   0365                     880 00125$:
                            881 ;proc.c:247: shutdown ();
                            882 ;	genCall
                            883 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0365 CDr00s00            884 	call	_shutdown
                            885 ;	genLabel
   0368                     886 00112$:
                            887 ;	genEndFunction
   0368 DD F9               888 	ld	sp,ix
   036A DD E1               889 	pop	ix
   036C C9                  890 	ret
   036D                     891 _proc_kill_end::
                            892 ;proc.c:257: exit (int code)
                            893 ;	genLabel
                            894 ;	genFunction
                            895 ;	---------------------------------
                            896 ; Function exit
                            897 ; ---------------------------------
   036D                     898 _exit_start::
   036D                     899 _exit:
   036D DD E5               900 	push	ix
   036F DD 21 00 00         901 	ld	ix,#0
   0373 DD 39               902 	add	ix,sp
                            903 ;proc.c:259: proc_kill (proc_current);
                            904 ;	genIpush
                            905 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0375 2Ar00s00            906 	ld	hl,(_proc_current)
   0378 E5                  907 	push	hl
                            908 ;	genCall
   0379 CDr6Es02            909 	call	_proc_kill
   037C F1                  910 	pop	af
                            911 ;proc.c:262: SWITCH();
                            912 ;	genCall
                            913 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   037D CDr00s00            914 	call	_machdep_switch
                            915 ;proc.c:265: panic ("proc_startup() shouldn't return!");
                            916 ;	genIpush
                            917 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0380 21r8Bs03            918 	ld	hl,#__str_4
   0383 E5                  919 	push	hl
                            920 ;	genCall
   0384 CDr00s00            921 	call	_panic
   0387 F1                  922 	pop	af
                            923 ;	genLabel
   0388                     924 00101$:
                            925 ;	genEndFunction
   0388 DD E1               926 	pop	ix
   038A C9                  927 	ret
   038B                     928 _exit_end::
   038B                     929 __str_4:
   038B 70 72 6F 63 5F 73   930 	.ascii "proc_startup() shouldn't return!"
        74 61 72 74 75 70
        28 29 20 73 68 6F
        75 6C 64 6E 27 74
        20 72 65 74 75 72
        6E 21
   03AB 00                  931 	.db 0x00
                            932 ;proc.c:275: proc_funexec (struct proc ** ret, void *func, size_t codesize, size_t datasize, size_t stacksize, char *name)
                            933 ;	genLabel
                            934 ;	genFunction
                            935 ;	---------------------------------
                            936 ; Function proc_funexec
                            937 ; ---------------------------------
   03AC                     938 _proc_funexec_start::
   03AC                     939 _proc_funexec:
   03AC DD E5               940 	push	ix
   03AE DD 21 00 00         941 	ld	ix,#0
   03B2 DD 39               942 	add	ix,sp
   03B4 21 FE FF            943 	ld	hl,#-2
   03B7 39                  944 	add	hl,sp
   03B8 F9                  945 	ld	sp,hl
                            946 ;proc.c:280: err = proc_create (ret, name);
                            947 ;	genIpush
                            948 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                            949 ;	AOP_STK for 
   03B9 DD 6E 0E            950 	ld	l,14(ix)
   03BC DD 66 0F            951 	ld	h,15(ix)
   03BF E5                  952 	push	hl
                            953 ;	genIpush
                            954 ;	AOP_STK for 
   03C0 DD 6E 04            955 	ld	l,4(ix)
   03C3 DD 66 05            956 	ld	h,5(ix)
   03C6 E5                  957 	push	hl
                            958 ;	genCall
   03C7 CDrA7s00            959 	call	_proc_create
   03CA 44                  960 	ld	b,h
   03CB 4D                  961 	ld	c,l
   03CC F1                  962 	pop	af
   03CD F1                  963 	pop	af
                            964 ;	genAssign
                            965 ;	(registers are the same)
                            966 ;proc.c:281: ERRCODE(err);
                            967 ;	genCmpEq
                            968 ; genCmpEq: left 2, right 2, result 0
   03CE 79                  969 	ld	a,c
   03CF B0                  970 	or	a,b
   03D0 CArD8s03            971 	jp	z,00102$
   03D3                     972 00112$:
                            973 ;	genRet
                            974 ; Dump of IC_LEFT: type AOP_REG size 2
                            975 ;	 reg = bc
   03D3 69                  976 	ld	l,c
   03D4 60                  977 	ld	h,b
   03D5 C3r72s04            978 	jp	00107$
                            979 ;	genLabel
   03D8                     980 00102$:
                            981 ;proc.c:282: p = *ret;
                            982 ;	genAssign
                            983 ;	AOP_STK for 
   03D8 DD 4E 04            984 	ld	c,4(ix)
   03DB DD 46 05            985 	ld	b,5(ix)
   03DE C5                  986 	push	bc
   03DF FD E1               987 	pop	iy
                            988 ;	genPointerGet
   03E1 FD 5E 00            989 	ld	e,0(iy)
   03E4 FD 56 01            990 	ld	d,1(iy)
                            991 ;	genAssign
                            992 ;	AOP_STK for _proc_funexec_p_1_1
   03E7 DD 73 FE            993 	ld	-2(ix),e
   03EA DD 72 FF            994 	ld	-1(ix),d
                            995 ;proc.c:284: p->codesize = codesize;
                            996 ;	genPlus
                            997 ;	AOP_STK for _proc_funexec_p_1_1
                            998 ;	genPlusIncr
                            999 ;	Can't optimise plus by inc, falling back to the normal way
   03ED DD 7E FE           1000 	ld	a,-2(ix)
   03F0 C6 12              1001 	add	a,#0x12
   03F2 5F                 1002 	ld	e,a
   03F3 DD 7E FF           1003 	ld	a,-1(ix)
   03F6 CE 00              1004 	adc	a,#0x00
   03F8 57                 1005 	ld	d,a
                           1006 ;	genAssign (pointer)
                           1007 ;	AOP_STK for 
                           1008 ;	isBitvar = 0
   03F9 6B                 1009 	ld	l,e
   03FA 62                 1010 	ld	h,d
   03FB DD 7E 08           1011 	ld	a,8(ix)
   03FE 77                 1012 	ld	(hl),a
   03FF 23                 1013 	inc	hl
   0400 DD 7E 09           1014 	ld	a,9(ix)
   0403 77                 1015 	ld	(hl),a
                           1016 ;proc.c:285: p->datasize = datasize;
                           1017 ;	genPlus
                           1018 ;	AOP_STK for _proc_funexec_p_1_1
                           1019 ;	genPlusIncr
                           1020 ;	Can't optimise plus by inc, falling back to the normal way
   0404 DD 7E FE           1021 	ld	a,-2(ix)
   0407 C6 16              1022 	add	a,#0x16
   0409 5F                 1023 	ld	e,a
   040A DD 7E FF           1024 	ld	a,-1(ix)
   040D CE 00              1025 	adc	a,#0x00
   040F 57                 1026 	ld	d,a
                           1027 ;	genAssign (pointer)
                           1028 ;	AOP_STK for 
                           1029 ;	isBitvar = 0
   0410 6B                 1030 	ld	l,e
   0411 62                 1031 	ld	h,d
   0412 DD 7E 0A           1032 	ld	a,10(ix)
   0415 77                 1033 	ld	(hl),a
   0416 23                 1034 	inc	hl
   0417 DD 7E 0B           1035 	ld	a,11(ix)
   041A 77                 1036 	ld	(hl),a
                           1037 ;proc.c:286: if (stacksize < 4096)
                           1038 ;	genCmpLt
                           1039 ;	AOP_STK for 
   041B DD 7E 0C           1040 	ld	a,12(ix)
   041E D6 00              1041 	sub	a,#0x00
   0420 DD 7E 0D           1042 	ld	a,13(ix)
   0423 DE 10              1043 	sbc	a,#0x10
   0425 D2r30s04           1044 	jp	nc,00104$
                           1045 ;proc.c:287: stacksize = 4096;
                           1046 ;	genAssign
                           1047 ;	AOP_STK for 
   0428 DD 36 0C 00        1048 	ld	12(ix),#0x00
   042C DD 36 0D 10        1049 	ld	13(ix),#0x10
                           1050 ;	genLabel
   0430                    1051 00104$:
                           1052 ;proc.c:288: p->stacksize = stacksize;
                           1053 ;	genPlus
                           1054 ;	AOP_STK for _proc_funexec_p_1_1
                           1055 ;	genPlusIncr
                           1056 ;	Can't optimise plus by inc, falling back to the normal way
   0430 DD 7E FE           1057 	ld	a,-2(ix)
   0433 C6 0E              1058 	add	a,#0x0E
   0435 5F                 1059 	ld	e,a
   0436 DD 7E FF           1060 	ld	a,-1(ix)
   0439 CE 00              1061 	adc	a,#0x00
   043B 57                 1062 	ld	d,a
                           1063 ;	genAssign (pointer)
                           1064 ;	AOP_STK for 
                           1065 ;	isBitvar = 0
   043C 6B                 1066 	ld	l,e
   043D 62                 1067 	ld	h,d
   043E DD 7E 0C           1068 	ld	a,12(ix)
   0441 77                 1069 	ld	(hl),a
   0442 23                 1070 	inc	hl
   0443 DD 7E 0D           1071 	ld	a,13(ix)
   0446 77                 1072 	ld	(hl),a
                           1073 ;proc.c:290: err = proc_exec (p, func);
                           1074 ;	genIpush
                           1075 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
                           1076 ;	AOP_STK for 
   0447 DD 6E 06           1077 	ld	l,6(ix)
   044A DD 66 07           1078 	ld	h,7(ix)
   044D E5                 1079 	push	hl
                           1080 ;	genIpush
                           1081 ;	AOP_STK for _proc_funexec_p_1_1
   044E DD 6E FE           1082 	ld	l,-2(ix)
   0451 DD 66 FF           1083 	ld	h,-1(ix)
   0454 E5                 1084 	push	hl
                           1085 ;	genCall
   0455 CDr6Cs01           1086 	call	_proc_exec
   0458 54                 1087 	ld	d,h
   0459 5D                 1088 	ld	e,l
   045A F1                 1089 	pop	af
   045B F1                 1090 	pop	af
                           1091 ;	genAssign
   045C 4B                 1092 	ld	c,e
   045D 42                 1093 	ld	b,d
                           1094 ;proc.c:291: if (err != ENONE) {
                           1095 ;	genCmpEq
                           1096 ; genCmpEq: left 2, right 2, result 0
   045E 79                 1097 	ld	a,c
   045F B0                 1098 	or	a,b
   0460 CAr70s04           1099 	jp	z,00106$
   0463                    1100 00113$:
                           1101 ;proc.c:292: proc_kill (p);
                           1102 ;	genIpush
                           1103 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0463 C5                 1104 	push	bc
                           1105 ;	AOP_STK for _proc_funexec_p_1_1
   0464 DD 6E FE           1106 	ld	l,-2(ix)
   0467 DD 66 FF           1107 	ld	h,-1(ix)
   046A E5                 1108 	push	hl
                           1109 ;	genCall
   046B CDr6Es02           1110 	call	_proc_kill
   046E F1                 1111 	pop	af
   046F C1                 1112 	pop	bc
                           1113 ;	genLabel
   0470                    1114 00106$:
                           1115 ;proc.c:295: return err;
                           1116 ;	genRet
                           1117 ; Dump of IC_LEFT: type AOP_REG size 2
                           1118 ;	 reg = bc
   0470 69                 1119 	ld	l,c
   0471 60                 1120 	ld	h,b
                           1121 ;	genLabel
   0472                    1122 00107$:
                           1123 ;	genEndFunction
   0472 DD F9              1124 	ld	sp,ix
   0474 DD E1              1125 	pop	ix
   0476 C9                 1126 	ret
   0477                    1127 _proc_funexec_end::
                           1128 ;proc.c:302: proc_sleep (struct proc *proc)
                           1129 ;	genLabel
                           1130 ;	genFunction
                           1131 ;	---------------------------------
                           1132 ; Function proc_sleep
                           1133 ; ---------------------------------
   0477                    1134 _proc_sleep_start::
   0477                    1135 _proc_sleep:
   0477 DD E5              1136 	push	ix
   0479 DD 21 00 00        1137 	ld	ix,#0
   047D DD 39              1138 	add	ix,sp
   047F 21 FB FF           1139 	ld	hl,#-5
   0482 39                 1140 	add	hl,sp
   0483 F9                 1141 	ld	sp,hl
                           1142 ;proc.c:310: if ((proc->state & PROC_RUNNING) == FALSE) {
                           1143 ;	genAssign
                           1144 ;	AOP_STK for 
   0484 DD 4E 04           1145 	ld	c,4(ix)
   0487 DD 46 05           1146 	ld	b,5(ix)
                           1147 ;	genPlus
                           1148 ;	AOP_STK for _proc_sleep_sloc1_1_0
                           1149 ;	genPlusIncr
                           1150 ;	Can't optimise plus by inc, falling back to the normal way
   048A 79                 1151 	ld	a,c
   048B C6 20              1152 	add	a,#0x20
   048D DD 77 FB           1153 	ld	-5(ix),a
   0490 78                 1154 	ld	a,b
   0491 CE 00              1155 	adc	a,#0x00
   0493 DD 77 FC           1156 	ld	-4(ix),a
                           1157 ;	genPointerGet
                           1158 ;	AOP_STK for _proc_sleep_sloc1_1_0
                           1159 ;	AOP_STK for _proc_sleep_sloc0_1_0
   0496 DD 6E FB           1160 	ld	l,-5(ix)
   0499 DD 66 FC           1161 	ld	h,-4(ix)
   049C 7E                 1162 	ld	a,(hl)
   049D DD 77 FD           1163 	ld	-3(ix),a
                           1164 ;	genAnd
                           1165 ;	AOP_STK for _proc_sleep_sloc0_1_0
   04A0 DD 7E FD           1166 	ld	a,-3(ix)
   04A3 E6 01              1167 	and	a,#0x01
   04A5 CAr1Fs05           1168 	jp	z,00108$
   04A8                    1169 00113$:
                           1170 ;proc.c:318: if (proc->lock != NULL)
                           1171 ;	genPlus
                           1172 ;	genPlusIncr
                           1173 ;	Can't optimise plus by inc, falling back to the normal way
   04A8 79                 1174 	ld	a,c
   04A9 C6 21              1175 	add	a,#0x21
   04AB 5F                 1176 	ld	e,a
   04AC 78                 1177 	ld	a,b
   04AD CE 00              1178 	adc	a,#0x00
   04AF 57                 1179 	ld	d,a
                           1180 ;	genPointerGet
   04B0 6B                 1181 	ld	l,e
   04B1 62                 1182 	ld	h,d
   04B2 5E                 1183 	ld	e,(hl)
   04B3 23                 1184 	inc	hl
   04B4 56                 1185 	ld	d,(hl)
                           1186 ;	genCmpEq
                           1187 ; genCmpEq: left 2, right 2, result 0
   04B5 7B                 1188 	ld	a,e
   04B6 B2                 1189 	or	a,d
   04B7 CArBDs04           1190 	jp	z,00115$
   04BA                    1191 00114$:
   04BA C3r1Fs05           1192 	jp	00108$
   04BD                    1193 00115$:
                           1194 ;proc.c:323: proc->state &= ~PROC_RUNNING;
                           1195 ;	genAnd
                           1196 ;	AOP_STK for _proc_sleep_sloc0_1_0
   04BD DD 7E FD           1197 	ld	a,-3(ix)
   04C0 E6 FE              1198 	and	a,#0xFE
                           1199 ;	genAssign (pointer)
                           1200 ;	AOP_STK for _proc_sleep_sloc1_1_0
                           1201 ;	isBitvar = 0
   04C2 DD 6E FB           1202 	ld	l,-5(ix)
   04C5 DD 66 FC           1203 	ld	h,-4(ix)
   04C8 77                 1204 	ld	(hl),a
                           1205 ;proc.c:324: next = (struct proc *) proc->next;
                           1206 ;	genPlus
                           1207 ;	genPlusIncr
   04C9 59                 1208 	ld	e,c
   04CA 50                 1209 	ld	d,b
   04CB 13                 1210 	inc	de
   04CC 13                 1211 	inc	de
                           1212 ;	genPointerGet
   04CD 6B                 1213 	ld	l,e
   04CE 62                 1214 	ld	h,d
   04CF 5E                 1215 	ld	e,(hl)
   04D0 23                 1216 	inc	hl
   04D1 56                 1217 	ld	d,(hl)
                           1218 ;	genAssign
                           1219 ;	AOP_STK for _proc_sleep_next_1_1
   04D2 DD 73 FE           1220 	ld	-2(ix),e
   04D5 DD 72 FF           1221 	ld	-1(ix),d
                           1222 ;proc.c:327: CLIST_REMOVE(&procs_running, proc);
                           1223 ;	genAssign
   04D8 59                 1224 	ld	e,c
   04D9 50                 1225 	ld	d,b
                           1226 ;	genIpush
                           1227 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   04DA C5                 1228 	push	bc
   04DB D5                 1229 	push	de
                           1230 ;	genIpush
   04DC 21r38s00           1231 	ld	hl,#_procs_running
   04DF E5                 1232 	push	hl
                           1233 ;	genCall
   04E0 CDr00s00           1234 	call	_clist_remove
   04E3 F1                 1235 	pop	af
   04E4 F1                 1236 	pop	af
   04E5 C1                 1237 	pop	bc
                           1238 ;proc.c:328: CLIST_INSERT(&procs_sleeping, proc);
                           1239 ;	genAssign
   04E6 59                 1240 	ld	e,c
   04E7 50                 1241 	ld	d,b
                           1242 ;	genIpush
                           1243 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   04E8 C5                 1244 	push	bc
   04E9 D5                 1245 	push	de
                           1246 ;	genIpush
   04EA 21r3Cs00           1247 	ld	hl,#_procs_sleeping
   04ED E5                 1248 	push	hl
                           1249 ;	genCall
   04EE CDr00s00           1250 	call	_clist_insert
   04F1 F1                 1251 	pop	af
   04F2 F1                 1252 	pop	af
   04F3 C1                 1253 	pop	bc
                           1254 ;proc.c:333: if (proc == proc_current) {
                           1255 ;	genCmpEq
                           1256 ; genCmpEq: left 2, right 2, result 0
   04F4 FD 21r00s00        1257 	ld	iy,#_proc_current
   04F8 FD 7E 00           1258 	ld	a,0(iy)
   04FB B9                 1259 	cp	c
   04FC C2r06s05           1260 	jp	nz,00116$
   04FF FD 7E 01           1261 	ld	a,1(iy)
   0502 B8                 1262 	cp	b
   0503 CAr09s05           1263 	jp	z,00117$
   0506                    1264 00116$:
   0506 C3r1Fs05           1265 	jp	00106$
   0509                    1266 00117$:
                           1267 ;proc.c:335: proc_current = (struct proc *) next->prev;
                           1268 ;	genPointerGet
                           1269 ;	AOP_STK for _proc_sleep_next_1_1
   0509 DD 6E FE           1270 	ld	l,-2(ix)
   050C DD 66 FF           1271 	ld	h,-1(ix)
   050F 7E                 1272 	ld	a,(hl)
   0510 FD 21r00s00        1273 	ld	iy,#_proc_current
   0514 FD 77 00           1274 	ld	0(iy),a
   0517 23                 1275 	inc	hl
   0518 7E                 1276 	ld	a,(hl)
   0519 FD 77 01           1277 	ld	1(iy),a
                           1278 ;proc.c:336: SWITCH();
                           1279 ;	genCall
                           1280 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   051C CDr00s00           1281 	call	_machdep_switch
                           1282 ;	genLabel
   051F                    1283 00106$:
                           1284 ;proc.c:341: return;
                           1285 ;	genRet
                           1286 ;proc.c:342: end:
                           1287 ;	genLabel
   051F                    1288 00108$:
                           1289 ;	genEndFunction
   051F DD F9              1290 	ld	sp,ix
   0521 DD E1              1291 	pop	ix
   0523 C9                 1292 	ret
   0524                    1293 _proc_sleep_end::
                           1294 ;proc.c:350: proc_wakeup (struct proc *proc)
                           1295 ;	genLabel
                           1296 ;	genFunction
                           1297 ;	---------------------------------
                           1298 ; Function proc_wakeup
                           1299 ; ---------------------------------
   0524                    1300 _proc_wakeup_start::
   0524                    1301 _proc_wakeup:
   0524 DD E5              1302 	push	ix
   0526 DD 21 00 00        1303 	ld	ix,#0
   052A DD 39              1304 	add	ix,sp
   052C 21 FF FF           1305 	ld	hl,#-1
   052F 39                 1306 	add	hl,sp
   0530 F9                 1307 	ld	sp,hl
                           1308 ;proc.c:358: if (proc->state & PROC_RUNNING) {
                           1309 ;	genAssign
                           1310 ;	AOP_STK for 
   0531 DD 4E 04           1311 	ld	c,4(ix)
   0534 DD 46 05           1312 	ld	b,5(ix)
                           1313 ;	genPlus
                           1314 ;	genPlusIncr
                           1315 ;	Can't optimise plus by inc, falling back to the normal way
   0537 79                 1316 	ld	a,c
   0538 C6 20              1317 	add	a,#0x20
   053A 5F                 1318 	ld	e,a
   053B 78                 1319 	ld	a,b
   053C CE 00              1320 	adc	a,#0x00
   053E 57                 1321 	ld	d,a
                           1322 ;	genPointerGet
                           1323 ;	AOP_STK for _proc_wakeup_sloc0_1_0
   053F 1A                 1324 	ld	a,(de)
   0540 DD 77 FF           1325 	ld	-1(ix),a
                           1326 ;	genAnd
                           1327 ;	AOP_STK for _proc_wakeup_sloc0_1_0
   0543 DD 7E FF           1328 	ld	a,-1(ix)
   0546 E6 01              1329 	and	a,#0x01
   0548 CAr4Es05           1330 	jp	z,00108$
   054B                    1331 00107$:
   054B C3r6Cs05           1332 	jp	00104$
   054E                    1333 00108$:
                           1334 ;proc.c:365: proc->state |= PROC_RUNNING;
                           1335 ;	genOr
                           1336 ;	AOP_STK for _proc_wakeup_sloc0_1_0
   054E DD 7E FF           1337 	ld	a,-1(ix)
   0551 F6 01              1338 	or	a,#0x01
                           1339 ;	genAssign (pointer)
                           1340 ;	isBitvar = 0
   0553 12                 1341 	ld	(de),a
                           1342 ;proc.c:368: CLIST_REMOVE(&procs_sleeping, proc);
                           1343 ;	genAssign
   0554 59                 1344 	ld	e,c
   0555 50                 1345 	ld	d,b
                           1346 ;	genIpush
                           1347 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 1 deSending: 0
   0556 C5                 1348 	push	bc
   0557 D5                 1349 	push	de
                           1350 ;	genIpush
   0558 21r3Cs00           1351 	ld	hl,#_procs_sleeping
   055B E5                 1352 	push	hl
                           1353 ;	genCall
   055C CDr00s00           1354 	call	_clist_remove
   055F F1                 1355 	pop	af
   0560 F1                 1356 	pop	af
   0561 C1                 1357 	pop	bc
                           1358 ;proc.c:369: CLIST_INSERT(&procs_running, proc);
                           1359 ;	genAssign
                           1360 ;	(registers are the same)
                           1361 ;	genIpush
                           1362 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0562 C5                 1363 	push	bc
                           1364 ;	genIpush
   0563 21r38s00           1365 	ld	hl,#_procs_running
   0566 E5                 1366 	push	hl
                           1367 ;	genCall
   0567 CDr00s00           1368 	call	_clist_insert
   056A F1                 1369 	pop	af
   056B F1                 1370 	pop	af
                           1371 ;proc.c:372: already_up:
                           1372 ;	genLabel
   056C                    1373 00104$:
                           1374 ;	genEndFunction
   056C DD F9              1375 	ld	sp,ix
   056E DD E1              1376 	pop	ix
   0570 C9                 1377 	ret
   0571                    1378 _proc_wakeup_end::
                           1379 ;proc.c:380: sleep ()
                           1380 ;	genLabel
                           1381 ;	genFunction
                           1382 ;	---------------------------------
                           1383 ; Function sleep
                           1384 ; ---------------------------------
   0571                    1385 _sleep_start::
   0571                    1386 _sleep:
                           1387 ;proc.c:386: proc_sleep (proc_current);
                           1388 ;	genIpush
                           1389 ; _saveRegsForCall: sendSetSize: 0 deInUse: 0 bcInUse: 0 deSending: 0
   0571 2Ar00s00           1390 	ld	hl,(_proc_current)
   0574 E5                 1391 	push	hl
                           1392 ;	genCall
   0575 CDr77s04           1393 	call	_proc_sleep
   0578 F1                 1394 	pop	af
                           1395 ;	genLabel
   0579                    1396 00101$:
                           1397 ;	genEndFunction
   0579 C9                 1398 	ret
   057A                    1399 _sleep_end::
                           1400 	.area _CODE
